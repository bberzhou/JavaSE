package blackberry.Chapter8Thread.ThreadBase;

/**
 * @Description:
 * @author: bberzhou@gmail.com
 * @date: 10/12/20 19:06
 * Create By IntelliJ IDEA
 */
public class MultiThread {
    /**
     *  程序、进程、线程：
     *      程序 = 数据结构+算法
     *      进程 ：资源分配的单位，一个动态的过程（是程序的一次执行过程，是一个动态的过程）----存在生命周期
     *      线程 ：作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器，多个线程共享同一个进程中的结构：方法区、堆
     *
     *      并行：多个CPU同时执行多个任务，
     *      并发：一个CPU同时（操作系统会分配时间片）执行多个任务
     *
     *      一个Java应用程序java.exe 至少三个线程，main()线程、gc()垃圾回收线程、异常处理线程
     *
     *      并行与并发的理解
     *          并行：多个CPU同时执行多个任务，
     *          并发：一个CPU（采用时间片轮转的方式）同时执行多个任务
     *
     *  1.线程的创建和使用
     *      Java中创建线程的方法：
     *          1）声明一个类去继承Thread类，这个子类重写run()方法
     *             说明两个问题：
     *              问题一：启动一个线程，必须调用start()方法，不能调用被重写的run()方法来启动线程。
     *              问题二：如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start()方法
     *          2）声明一个类实现Runnable接口，这个类再去实现run()方法
     *
     *
     *     比较创建线程的两种方式:
     *          开发中优先选择使用runnable接口的方式，
     *                      原因：1、实现的方式没有类的单继承性的局限性
     *                      原因：2、实现的方式更合适来处理多个线程共享数据的情况
     *
     *          相同点：两种方式都需要重写run()函数，将线程要执行的逻辑声明在run()中。
     *                  目前两种方式，如果想要启动线程，都是调用Thread类中的start()方法
     *
     *  2.线程的生命周期
     *       JDK中使用Thread.State类定义了线程的几种状态，线程的五种状态
     *          新建：当一个Thread类或子类的对象被声明并创建时，新生的线程对象处于新建状态
     *          就绪：新建状态被start()后，进入线程队列等待CPU时间片，此时已经具备运行条件
     *          运行：就绪线程被调度，并获得CPU资源时便进入运行状态，run()方法定义了线程的操作和功能
     *          阻塞：让出CPU并临时中止自己的执行，进入阻塞状态
     *          死亡：线程完成全部工作或线程被提前强制性地中止或出现异常导致结束
     *
     *  3.线程的同步
     *    问题：多个线程执行的不确定性引起执行结果的不确定
     *          多个线程对账本的共享，会造成操作的不完整性，会破坏数据
     *
     *
     *  4.线程的通信
     *      线程通信的几个方法：wait()/ notify() / notifyAll():这三个方法定义在Object类中
     *
     *  Java中的线程分为两类：一种是守护线程（比如GC线程），一种是用户线程（比如main），
     *      通过在start()方法前调用Thread.setDaemon(true)，可以把一个用户线程变成一个守护线程
     */

}
