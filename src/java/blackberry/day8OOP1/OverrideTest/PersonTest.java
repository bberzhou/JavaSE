package blackberry.day8OOP1.OverrideTest;

/**
 * @Description: 测试重写
 * @author: bberzhou@gmail.com
 * @date: 4/14/20 21:25
 * Create By IntelliJ IDEA
 */
public class PersonTest {
    /*
        1。重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
        2。应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，
                实际执行的是子类重写父类的方法
        3。重写的规定：
                方法的声明： 权限修饰符  返回值类型  方法名(参数列表)throws 异常的类型{
                                    //  方法体
                                }
               1）子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同
               2）子类重写的方法的权限修饰符不小于父类的被重写方法的权限修饰符
               3）特殊情况，子类中不能重写父类中声明为private权限的方法
               4）返回值类型：
                    a,如果父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型也只能是void
                    b,如果父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或者A类的子类
                    c,如果父类被重写的方法的返回值类型是基本数据类型(int)，则子类重写的方法的返回值类型必须是相同的基本数据类型9(int)
               5)子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型


               子类和父类中的同名同参数的方法，要么都声明为非static的(考虑重写)，
               要么都声明为static的(不是重写)，静态的方法不能够被覆盖

         问：如何区分方法的重载和重写？
         1，首先区分重载重写的定义
         2，重载和重写的一些具体规则
         3，重载不表现为多态性，重写表现为多态性（子类和父类同名的方法）

     */
    public static void main (String[] args) {
        Student s = new Student ("计算机");
        s.eat ();
        //  输出
        //  走路,走了10 公里。
        //  show方法输出的：我是一个人
        //  此时由于子类student重写了父类的方法，所以输出 ：不吃饭
        s.walk (10);
        System.out.println ("***************");
        s.study ();
    }
}
