package lanqiaobei;

import java.util.ArrayList;
import java.util.Scanner;

/**
 * @Description:
 * @author: bberzhou@gmail.com
 * @date: 4/16/21 12:51
 * Create By IntelliJ IDEA
 */
public class ADV364DP {
    /*
        A同学的学习成绩十分不稳定，于是老师对他说：“只要你连续4天成绩有进步，那我就奖励给你一朵小红花。”
        可是这对于A同学太困难了。于是，老师对他放宽了要求：“只要你有4天成绩是递增的，我就奖励你一朵小红花。”
        即只要对于第i、j、k、l四天，满足i<j<k<l并且对于成绩wi<wj<wk<wl，
        那么就可以得到一朵小红花的奖励。现让你求出，A同学可以得到多少朵小红花。

        ----找序列


        input:
            第一行一个整数n，表示总共有n天。第二行n个数，表示每天的成绩wi。
        output:
            一个数，表示总共可以得到多少朵小红花。
     */
    public static void main (String[] args) {
        Scanner in = new Scanner (System.in);
        int len = in.nextInt ();
        int count = 0;
        ArrayList<Integer> arrayList = new ArrayList<> ();
        for (int i = 0 ; i < len ; i++) {
            arrayList.add (in.nextInt ());
        }
        //  外层for循环天数
        for (int i = 0 ; i < len ; i++) {

        }


        /*
            动态规划问题：
                对于Ai+1需要前面的所有前序状态才能完成推理过程。
                我们将这一模型称为高阶马尔科夫模型。对应的推理过程叫做“动态规划法”。
                能采用动态规划求解的问题的一般要具有3个性质：
                (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
               （2） 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。
                        也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
               （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。
                        （该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）

                 动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。
                 这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。
                 如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤


                 使用动态规划求解问题，最重要的就是确定动态规划三要素
                    （1）问题的阶段
                    （2）每个阶段的状态
                    （3）从前一个阶段转化到后一个阶段之间的递推关系

                 整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，
                 表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），
                 填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

                 f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}


                算法实现的具体步骤：
                1、创建一个一维数组或者二维数组，保存每一个子问题的结果，具体创建一维数组还是二维数组看题目而定，
                    基本上如果题目中给出的是一个一维数组进行操作，就可以只创建一个一维数组，
                    如果题目中给出了两个一维数组进行操作或者两种不同类型的变量值，
                     比如背包问题中的不同物体的体积与总体积，找零钱问题中的不同面值零钱与总钱数，这样就需要创建一个二维数组。

                    注：创建二维数组的解法，都可以创建一个一维数组运用滚动数组的方式来解决，即一维数组中的值不停的变化

                2、设置数组边界值，一维数组就是设置第一个数字，二维数组就是设置第一行跟第一列的值，
                    特别的滚动一维数组是要设置整个数组的值，然后根据后面不同的数据加进来变幻成不同的值。
                3、找出状态转换方程，也就是说找到每个状态跟他上一个状态的关系，根据状态转化方程写出代码。

                4、返回需要的值，一般是数组的最后一个或者二维数组的最右下角。

                    代码基本框架：

         for (j = 1; j <= m ; j = j + 1) // 第一个阶段
//            xn[j] = 初始值;
//
//        for (i = n - 1; i >= 1 ; i = i - 1)// 其他n-1个阶段
//            for (j = 1; j >= f (i) ; j = j + 1)//f(i)与i有关的表达式
//                xi[j] = j = max（或min）{
//            g (xi -[j1:j2]), ......,g (xi - 1[jk:jk + 1])} ;
//
//        t = g (x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案
//
//        print (x1[j1]);
//
//        for (i = 2; i <= n - 1 ; i = i + 1）
//        {
//            t = t - xi - 1[ji];
//
//            for (j = 1; j >= f (i) ; j = j + 1)
//                if (t = xi[ji])
//                    break;
//        }


         */

    }

}
